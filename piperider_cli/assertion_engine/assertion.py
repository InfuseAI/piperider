import os

from ruamel import yaml
from ruamel.yaml.comments import CommentedMap, CommentedSeq


def safe_load_yaml(file_path):
    payload = None
    with open(file_path, 'r') as f:
        try:
            payload = yaml.safe_load(f)
        except yaml.YAMLError as e:
            print(e)
            return None
    return payload


def load_yaml_configs(path):
    passed = []
    failed = []
    content = {}
    for root, dirs, files in os.walk(path):
        for file in files:
            if file.endswith('.yml') or file.endswith('.yaml'):
                file_path = os.path.join(root, file)
                payload = safe_load_yaml(file_path)
                if not payload:
                    failed.append(file_path)
                else:
                    passed.append(file_path)
                    content.update(payload)

    return passed, failed, content


class AssertionEngine:
    """
    This class is used to evaluate the assertion.
    """
    PIPERIDER_WORKSPACE_NAME = '.piperider'
    PIPERIDER_ASSERTION_SEARCH_PATH = os.path.join(os.getcwd(), PIPERIDER_WORKSPACE_NAME, 'assertions')
    PIPERIDER_ASSERTION_SUPPORT_METRICS = ['distribution', 'range', 'missing_value']

    def __init__(self, datasource, profiler, assertion_search_path=PIPERIDER_ASSERTION_SEARCH_PATH):
        self.datasource = datasource
        self.profiler = profiler
        self.assertion_search_path = assertion_search_path
        self.assertions_content = {}
        pass

    @staticmethod
    def check_assertions_syntax(assertion_search_path=PIPERIDER_ASSERTION_SEARCH_PATH):
        """
        This method is used to check the syntax of the assertion.
        :param assertion_search_path:
        :return:
        """
        return load_yaml_configs(assertion_search_path)

    def load_assertions(self):
        """
        This method is used to load assertions from the specific path.
        :param assertion_search_path:
        :return:
        """
        passed_assertion_files, failed_assertion_files, self.assertions_content = load_yaml_configs(
            self.assertion_search_path)
        pass

    def generate_assertion_templates(self):
        """
        This method is used to generate assertion templates.
        :param assertion_search_path:
        :return:
        """

        if not self.assertions_content:
            self.load_assertions()

        for table in list(self.profiler.metadata.tables):
            if table in self.assertions_content:
                continue
            assertion = CommentedMap({table: CommentedMap()})
            assertion.yaml_set_start_comment(
                f'# Auto-generated by Piperider CLI based on datasource "{self.datasource.name}" table "{table}"')
            assertion.yaml_add_eol_comment('Table Name', table)
            for column in self.profiler.metadata.tables[table].columns:
                # Columns
                column_name = str(column.name)
                assertion[table][column_name] = CommentedMap()
                assertion[table].yaml_add_eol_comment('Column Name', column_name)
                for metric in self.PIPERIDER_ASSERTION_SUPPORT_METRICS:
                    # Metrics
                    assertion[table][column_name][metric] = CommentedSeq()
                    assertion[table][column_name].yaml_add_eol_comment('Metric', metric)

            file_path = os.path.join(self.assertion_search_path, f'{self.datasource.name}-{table}.yml')
            with open(file_path, 'w') as f:
                print(
                    f'Generating assertion template for datasource "{self.datasource.name}" table "{table}" -> {file_path}')
                yaml.YAML().dump(assertion, f)
        pass

    def evaluate(self, assertion):
        """
        This method is used to evaluate the assertion.
        :param assertion:
        :return:
        """
        pass
